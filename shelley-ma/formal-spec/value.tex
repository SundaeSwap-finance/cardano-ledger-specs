\section{Coin and Multi-Asset Tokens}
\label{sec:coin-ma}

This ShelleyMA specification allows us to have a single version of a ledger
spec for both Allegra and Mary eras because we introduce an abstract type,
$\ValClass$, that allows us to swap out the representation of ledger assets that
are just Ada (ie. $\Coin$) for a type that represents multiple assets in a
single term (eg. $\Value$), as well as swap out the type-specific functions
used in the ledger rules and required for $\ValClass$ instantiation (see Figure \ref{fig:valclass}).
We do so by instantiating $\ValClass$ to either one of the types. Note that
it can, in theory, be instantiated to any other type on which we can meaningfully
define the required functions (addition, size, etc.).

\subsection{$\ValClass$}

$\ValClass$ is intuitively used as a placeholder for any type that can be used
to represent (inside a transaction or in the ledger UTxO) quantities of a single asset or several different assets.
Figure \ref{fig:valclass} gives names and types of functions in which $\ValClass$ is either
an argument or the output type, and so they cannot be defined without assigning
the abstract $\ValClass$ a specific type. Because these functions are used in the
Allegra and Mary transition rules, to define the two concrete ledger models,
we must not only pick a type with which to instantiate the $\ValClass$ abstraction,
but also give concrete definitions to the associated functions.


%%
%% Figure ValClass and its Functions
%%
\begin{figure}[htb]
  \emph{Helper function}
  %
  \begin{align*}
    \mathsf{ValType} &\in \ValClass  \\
    \text{Abstract type of asset-representing terms}
  \end{align*}
  %
  \emph{Function definitions required for $\ValClass$ instantiation}
  %
  \begin{align*}
      & \mathsf{ValType} ~\in~ \ValClass  \\
      & \text{Arbitrary type instance}
      \nextdef
      %
      & \fun{zero} ~\in~ \mathsf{ValType} \\
      & \text{Additive identity of $\mathsf{ValType}$}
      \nextdef
      %
      & (+) ~\in~ \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Addition on $\mathsf{ValType}$}
      \nextdef
      %
      & (*) ~\in~ \mathsf{Integer} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Scale $\mathsf{ValType}$ value by integral constant}
      \nextdef
      %
      & (-) ~\in~ \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & v_1~-~v_2 ~=~ v_1~+~((-1)~*~v_2)\\
      & \text{Subtraction on $\mathsf{ValType}$}
      \nextdef
      %
      & \fun{isZero} ~\in~ \mathsf{ValType} \to \Bool\\
      & \fun{isZero}~v ~+~ v~=~\fun{zero} \\
      & \text{Is a given $\mathsf{ValType}$ term the additive identity?}
      \nextdef
      %
      & \fun{coin} ~\in~ \mathsf{ValType} \to \Coin\\
      & \text{Return the Ada contained in a $\mathsf{ValType}$ term}
      \nextdef
      %
      & \fun{inject} ~\in~ \Coin \to \mathsf{ValType}\\
      & \text{Create a $\mathsf{ValType}$ term containing only this amount of Ada}
      \nextdef
      %
      & \fun{adaOnly} ~\in~ \ValClass \to \Bool \\
      & \fun{adaOnly}~v =
        \begin{cases}
          \True & \fun{inject} \circ \fun{coin} = \fun{id}_{\ValClass} \\
          \False & \text{otherwise}
        \end{cases} \\
      & \text{Check if a given $\mathsf{ValType}$ term contains only Ada}
      \nextdef
      %
      & \fun{modifyCoin} ~\in~ (\Coin \to \Coin) \to (\mathsf{ValType} \to \mathsf{ValType})\\
      & \text{Modify the Ada part of $\mathsf{ValType}$}
      \nextdef
      %
      & \fun{size} ~\in~ \mathsf{ValType} \to \MemoryEstimate\\
      & \text{Return the size in words of a $\mathsf{ValType}$ term}
      \nextdef
      %
      & \fun{pointwise} ~\in~ (\Integer \to \Integer \to \Bool) \to (\mathsf{ValType} \to \mathsf{ValType} \to \Bool)\\
      & \text{Pointwise comparison of two $\mathsf{ValType}$ terms}
  \end{align*}
  \caption{$\ValClass$ and its Functions}
  \label{fig:valclass}
\end{figure}

\subsection{$\Coin$ in the Allegra era}

There are several ways to instantiate $\ValClass$ with a concrete type in a sensible way.
For the Allegra era, we require the instance of it to represent a single asset, Ada. Hence
we instantiate it with $\Coin$. This section defines the functions
required for $\ValClass$ instantiation with $\Coin$. We give these in Figure
\ref{fig:coin}. Addition and multiplication are defined in the usual way
(as on $\Integer$).

When multi-asset support on the ledger is introduced, Ada ($\Coin$) is still expected to be
the most common type of token on the ledger.
It is the only
type of token that can be used for all non-UTxO ledger accounting, including deposits,
fees, rewards, treasury, and the proof of stake protocol. For this reason, not
all instances of $\Coin$ inside a transaction or in the ledger state can or
should be replaced with the abstract $\ValClass$.

%%
%% Figure Coin Functions
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{zero} ~=~ 0
      \nextdef
      %
      & \fun{coin} ~=~ \fun{id}_{\Coin}
      \nextdef
      %
      & \fun{inject} ~=~ \fun{id}_{(\Coin \to \Coin)}
      \nextdef
      %
      & \fun{modifyCoin} ~=~ \fun{id}_{(\Coin \to \Coin)}
      \nextdef
      %
      & \fun{size}~\wcard ~=~ 0
      \nextdef
      %
      & \fun{pointwise} ~=~ \fun{id}_{(\Integer \to \Integer \to \Bool)}
  \end{align*}
  \caption{Function definitions required for $\ValClass$ instantiation with $\Coin$}
  \label{fig:coin}
\end{figure}

\textbf{Relation between $\fun{inject}$ and $\fun{coin}$.}
When composed as

\[\fun{coin} \circ \fun{inject} = \fun{id}_{\Coin}\]

these functions give the identity on $\Coin$, but composed in the opposite order as

\[\fun{inject} \circ \fun{coin}\]

they return a $\ValClass$ containing only the Ada tokens contained in the original $\ValClass$.

\textbf{Fungible and non-fungible tokens.}
Recall that a token is said to be fungible at a specific time (slot $s$, for example) if
there are two or more tokens in existence on the ledger that are indistinguishable from
each other, ie. they have the exact same identifier. Tokens with the same
identifier are fungible with each other, but not with tokens with a different identifier.

If there exists only a single
token with a given identifier, it is said to be unique (or non-fungible).
The usual meaning of \emph{non-fungible token} implies, additionally to the
requirement that a token is unique on the ledger at a given time, that
it is programmatically guaranteed to remain unique indefinitely. This
type of guarantee can be encoded in a minting policy.


\subsection{Multi-assets and $\Value$ in the Mary Era}

$\Value$ is the type to which
$\ValClass$ is instantiated in the Mary era to support transacting with
multiple types of assets, both user-defined and minted, and Ada. Terms of this
type represent heterogeneous collections of assets. This
This section describes the type $\Value$, the operations required on
it, and its relation to $\Coin$.

Figure \ref{fig:defs:value} introduces the basic types that make up the $\Value$ type,
as well as some of the basic functions needed for $\ValClass$ instantiation.

\begin{figure*}[t!]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{aname} & ~\AssetName & \mathsf{ByteString} \\
      \var{pid} & \PolicyID & \ScriptHash \\
      \var{aid} & \AssetID & \PolicyID \times \AssetName \\
      \var{quan} & \Quantity & \Z \\
      %\text{quantity of a token}\\
      \var{v}, \var{w} & \Value
      & \Coin \times \PolicyID \to_0 ( \AssetName \to_0 \Quantity )
%      & \text{a collection of tokens}
    \end{array}
  \end{equation*}
  %
  \emph{Functions required for $\ValClass$ instantiation with $\Value$}
  %
  \begin{align*}
    & \fun{pids} ~\in~ \Value \to \powerset{\PolicyID} \\
    & \fun{pids}~v ~=~ \supp{~v}
    \nextdef
    %
    & \fun{anames} ~\in~ \Value \to \powerset{\PolicyID} \\
    & \fun{anames}~v ~=~ \bigcup_{pid \in\fun{pids}{~v}} \supp{v~pid}
    \nextdef
    %
    & \fun{zero} ~=~ (0, \Nothing)
    \nextdef
    %
    & \fun{coin}~(\var{c}, \wcard) ~=~ \var{c}
    \nextdef
    %
    & \fun{inject}~c  ~=~ (c, \Nothing)
    \nextdef
    %
    & \fun{modifyCoin}~f~(c, v)  ~=~ \var{(f(c), v)}
    \nextdef
    %
    & \fun{size} ~~~ \text{see Section \ref{sec:value-size}}
  \end{align*}
  \caption{Type Definitions and auxiliary functions for Value}
  \label{fig:defs:value}
\end{figure*}

\begin{itemize}
  \item $\PolicyID$ identifies monetary policies. A policy ID $\var{pid}$ is associated with a script
    $s$ such that $\fun{hashScript}~s~=~pid$. When a transaction attempts to create or destroy tokens
    that fall under the policy ID $\var{pid}$,
    $s$ verifies that the transaction
    respects the restrictions that are imposed by the monetary policy.
    See sections \ref{sec:transactions} and \ref{sec:utxo} for details.

  \item $\AssetName$ is a byte string used to distinguish different tokens with the same $\PolicyID$.
    Each $aname$ identifies a unique kind of token in $\var{pid}$. The maximum length of this
    byte string is 32 bytes (this is not explicitly enforced in this spec).

  \item $\AssetID$ is a pair of the policy ID and the asset name. It is a unique and permanent
  identifier of an asset. That is, there are is no mechanism to change it or
  any part of it.

  Mary MA tokens are fungible with each other if and only if they belong to the same $\AssetID$,
  i.e. they have the same $\PolicyID$ and $\AssetName$.
  The reason the unique identifier is a pair of two terms is to allow
  minting arbitrary collections of fungible and unique tokens under a single policy.

  \item $\Quantity$ is an integer type that represents an amount of a specific $\AssetName$. We associate
    a term $q\in\Quantity$ with a specific token to track how much of that token is contained in a given asset value.

  \item $\Value$ is the multi-asset type that is used to represent
    a collection of tokens, including Ada. This type is a pair, where the first
    term represents the amount of Ada in the collection, and the second term
    represents all other assets except Ada.

    If $(\var{pid}, \var{aname})$ is an $\AssetID$ and $v \in \Value$,
    the quantity in $v$ belonging to that $\AssetID$ is $v~\var{pid}~\var{aname}$.
    Terms of type $\Value$ are sometimes also referred to as
    \emph{token bundles}.

   To be precise, the multi-asset
   type, $\Value$ is a finitely supported function of two variables,
   $\PolicyID$ and $\AssetName$ to $\Quantity$.

  \item $\fun{inject}$ takes a $\Coin$ amount and returns a $\Value$ containing
  that amount of Ada and no other assets.

  \item $\fun{coin}$ returns the amount of Ada contained in a $\Value$ term (ie.
  the first term of the pair).
\end{itemize}

\textbf{The Ada special case.} Making Ada a special case in the $\Value$ definition is useful
because Ada is the most common type of asset on the ledger. It also can
be used for special purposes (such as fees) for which other assets cannot be used.
Moreover, it is unlikely that tokens other than Ada can ever be used for this
purpose, as the underlying consensus algorithm relies on Ada in a way that
cannot be extended to user-defined tokens.
We sometimes refer to Ada as the primary or principal currency. Ada does not,
for the purposes of the Mary ledger spec, have a $\PolicyID$ or an $\AssetName$.

\subsection{Value Operations and Partial Order}
To fully describe $\ValClass$ instantiation with $\Value$, we require
additional operations on $\Value$, including binary relations, addition, and
scalar multiplication. These are all done
pointwise in accordance with the usual definitions of these operations on
finitely supported maps, see Figure \ref{fig:pointwise}.

\begin{figure*}[t!]
  \begin{align*}
    & (c, v)~+~(d, w) =& (c+d, ~\{~ pid\mapsto_0 (aname\mapsto_0 (v~\var{pid}~\var{aname})~+~(w~\var{pid}~\var{aname}) ~\vert~ \\
    & & \var{pid} \in (\fun{pids}~v~\cup~\fun{pids}~w),~\var{aname}~\in~(\fun{anames}~v~\cup~\fun{anames}~w) ~\} )
    \nextdef
    %
    & q~*~(c, v) =& (q*c, ~\{~ pid\mapsto_0 (aname\mapsto_0 (q~*~(v~\var{pid}~\var{aname})) ~\vert~ \\
    & & \var{pid} \in \fun{pids}~v,~\var{aname}~\in~\fun{anames}~v ~\} )
    \nextdef
    %
    & \fun{pointwise}~R~(c, v)~(d, w) =& (c~=~d) \wedge \forall~(\var{pid} \in \fun{pids}~v~\cup~\fun{pids}~u), \\
    & & \forall~(\var{aname}~\in~\fun{anames}~v~\cup~\fun{anames}~u),~R~(v~\var{pid}~\var{aname})~(w~\var{pid}~\var{aname})
  \end{align*}
  \caption{Pointwise operations on Value}
  \label{fig:pointwise}
\end{figure*}

\subsection{Other Instances of $\ValClass$.}

There are other options for defining a $\ValClass$ instance. We give examples here
that are actual $\Value$-like types that used elsewhere (eg. the wallet).

\begin{itemize}
  \item The compact representation of $\Value$, $\mathsf{CompactValue}$. This
  is a compressed representation of $\Value$ that is isomorphic to it.
  All the $\ValClass$ operations
  are defined directly in terms of $\Value$ operations, by first converting
  to $\Value$, performing the operation, then converting back.

  \item The un-Curried representation of the map part of $\Value$. That is,
  the map term in $\Value$ has the type

  \[ \AssetID \mapsto \Quantity \]

  In this representation, which is also isomorphic to $\Value$, doing the
  $\ValClass$ operations pointwise directly on this type commutes with conversion to
  and from $\Value$.

  \item A $\Value$ representation that is not a pair of $\Coin$ and a map, but just
  the un-Curried map. Here, Ada is presented as having an $\AssetID$,
  like the other assets. It is still special, though, since we define a new
  $\AssetID$ type to be

  \[ \mathsf{AssetID'} ~=~ \mathsf{AdaID} \uniondistinct \AssetID \]

  This type is again isomorphic to $\Value$, with commuting operations. For
  example, the $\fun{inject}$ and $\fun{coin}$ maps are defined as follows :

  \[ \fun{inject}~c = \{ \mathsf{AdaID}~\mapsto~c \} \]

  \[ \fun{coin}~v = v~\mathsf{AdaID} \]
\end{itemize}
