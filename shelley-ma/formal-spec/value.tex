\section{Coin and Multi-Asset Tokens}
\label{sec:coin-ma}

This ShelleyMA specification allows us to have a single version of a ledger
spec for both Allegra and Mary eras because we introduce an abstract type,
$\ValClass$, that allows us to swap out the representation of ledger assets that
are just Ada (ie. $\Coin$) for a type that represents multiple assets in a
single term (eg. $\Value$), as well as swap out the type-specific functions
used in the ledger rules and required by $\ValClass$ (see Figure \ref{fig:valclass}).
We do so by instantiating $\ValClass$ to either one of the types. Note that
it can, in theory, be instantiated to any other type on which we can meaningfully
define the required functions (addition, size, etc.).

\subsection{$\ValClass$}

$\ValClass$ is intuitively used as a placeholder for any type that can be used
to represent (inside a transaction or in the ledger UTxO) quantities of a single asset or several different assets.
Figure \ref{fig:valclass} gives names and types of functions in which $\ValClass$ is either
an argument or the output type, and so they cannot be defined without assigning
the abstract $\ValClass$ a specific type. Because these functions are used in the
Allegra and Mary transition rules, to define the two concrete ledger models,
we must not only pick a type with which to instantiate the $\ValClass$ abstraction,
but also give concrete definitions to the associated functions.


%%
%% Figure ValClass and its Functions
%%
\begin{figure}[htb]
  \emph{Helper function}
  %
  \begin{align*}
    \mathsf{ValType} &\in \ValClass  \\
    \text{Abstract type of asset-representing terms}
  \end{align*}
  %
  \emph{Function definitions required for $\ValClass$ instantiation}
  %
  \begin{align*}
      & \mathsf{ValType} &\in \ValClass & \text{Arbitrary type instance} \\~\\
      %
      & \fun{zero} &\in \mathsf{ValType} \\
      & \text{Additive identity of $\mathsf{ValType}$}\\~\\
      %
      & (+) &\in \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Addition on $\mathsf{ValType}$}\\~\\
      %
      & (*) &\in \mathsf{Integer} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Scale $\mathsf{ValType}$ value by integral constant}\\~\\
      %
      & (-) &\in \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & v_1~-~v_2) &= v_1~+~((-1)~*~v_2)\\
      & \text{Subtraction on $\mathsf{ValType}$}\\~\\
      %
      & \fun{isZero} &\in \mathsf{ValType} \to \Bool\\
      & \text{Is a given $\mathsf{ValType}$ term the additive identity?}\\~\\
      %
      & \fun{coin} &\in \mathsf{ValType} \to \Coin\\
      & \text{Return the Ada contained in a $\mathsf{ValType}$ term}\\~\\
      %
      & \fun{inject} &\in \Coin \to \mathsf{ValType}\\
      & \text{Create a $\mathsf{ValType}$ term containing only this amount of Ada}\\~\\
      %
      & \fun{modifyCoin} &\in (\Coin \to \Coin) \to (\mathsf{ValType} \to \mathsf{ValType})\\
      & \text{Modify the Ada part of $\mathsf{ValType}$}\\~\\
      %
      & \fun{size} &\in \mathsf{ValType} \to \MemoryEstimate\\
      & \text{Return the size in words of a $\mathsf{ValType}$ term}\\~\\
      %
      & \fun{pointwise} &\in (\Integer \to \Integer \to \Bool) \to (\mathsf{ValType} \to \mathsf{ValType} \to \Bool)\\
      & \text{Pointwise comparison of two $\mathsf{ValType}$ terms}
  \end{align*}
  \caption{$\ValClass$ and its Functions}
  \label{fig:valclass}
\end{figure}

\subsection{$\Coin$ in the Allegra era}

There are several ways to instantiate $\ValClass$ with a concrete type in a sensible way.
For the Allegra era, we require the instance of it to represent a single asset, Ada. Hence
we instantiate it with $\Coin$. This section defines the functions
required for $\ValClass$ instantiation with $\Coin$. We give these in Figure
\ref{fig:coin}. Addition and multiplication are defined in the usual way
(as on $\Integer$).

When multi-asset support on the ledger is introduced, Ada ($\Coin$) is still expected to be
the most common type of token on the ledger.
It is the only
type of token that can be used for all non-UTxO ledger accounting, including deposits,
fees, rewards, treasury, and the proof of stake protocol. For this reason, not
all instances of $\Coin$ inside a transaction or in the ledger state can or
should be replaced with the abstract $\ValClass$.

%%
%% Figure Coin Functions
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{zero} &\in \mathsf{ValType} \\~\\
      %
      & \fun{coin} &\in \fun{id}_{\Coin}\\~\\
      %
      & \fun{inject} &\in \fun{id}_{(\Coin \to \Coin)} \\~\\
      %
      & \fun{modifyCoin} &\in \fun{id}_{(\Coin \to \Coin)} \\~\\
      %
      & \fun{size} \wcard &= 0 \\~\\
      %
      & \fun{pointwise} &= \fun{id}_{(\Integer \to \Integer \to \Bool)}
  \end{align*}
  \caption{Function definitions required for $\ValClass$ instantiation with $\Coin$}
  \label{fig:coin}
\end{figure}

\subsection{Multi-assets and $\Value$}

Another way to instantiate $\ValClass$ is with $\Value$, which is the type to which
$\ValClass$ is instantiated in the Mary era to support transacting with
multiple types of assets, both user-defined and minted, and Ada. Terms of this
type represent heterogeneous collections of assets. This
This section describes the type $\Value$, the operations required on
it, and its relation to $\Coin$.

Figure \ref{fig:defs:value} introduces the basic types that make up the $\Value$ type.

\begin{figure*}[t!]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{aname} & ~\AssetName & \mathsf{ByteString} \\
      \var{pid} & \PolicyID & \ScriptHash \\
      \var{quan} & \Quantity & \Z \\
      %\text{quantity of a token}\\
      \var{v}, \var{w} & \Value
      & \PolicyID \to_0 ( \AssetName \to_0 \Quantity )
%      & \text{a collection of tokens}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \mathsf{adaPolicy} \in& ~\PolicyID & \text{Ada Policy ID} \\
    \mathsf{adaName} \in& ~\AssetName & \text{Ada Asset Name} \\
    \mathsf{size} \in& ~\Value\to\MemoryEstimate & \text{the size of a Value}
  \end{align*}
  \emph{Helper Functions}
  %
  \begin{align*}
    & \fun{inject} \in \Coin\to \Value \\
    & \fun{inject}~c = \lambda~\var{pid}~\var{aname}.
      \begin{cases}
        c & \var{pid} = \mathsf{adaPolicy}~\text{and}~\var{aname} = \mathsf{adaName} \\
        0 & \text{otherwise}
      \end{cases}
    \nextdef
    & \fun{coin} \in \Value \to \Coin \\
    & \fun{coin}~v = v~\mathsf{adaPolicy}~\mathsf{adaName}
    \nextdef \fun{inject} \circ \fun{coin}
    & \fun{adaOnly} \in \Value \to \Bool \\
    & \fun{adaOnly}~v =
      \begin{cases}
        \True & \fun{inject} \circ \fun{coin} = \fun{id}_{\Value} \\
        \False & \text{otherwise}
      \end{cases}
  \end{align*}
  \caption{Type Definitions and auxiliary functions for Value}
  \label{fig:defs:value}
\end{figure*}

We will refer to a pair of a $\PolicyID$ and an
$\AssetName$ as an $\AssetID$. The $\AssetID$ for Ada is $(\mathsf{adaPolicy}, \mathsf{adaName})$.
This is symbolic only, no actual minting policy for Ada exists.

The set of tokens that are referred to by the underlying monetary
policy represents the coinage that the asset supports. A multi-asset
value, $\Value$ is a finitely supported function of two variables,
$\PolicyID$ and $\AssetName$ to $\Quantity$.

\begin{itemize}
  \item $\PolicyID$ identifies monetary policies. A policy ID $\var{pid}$ is associated with a script
    $s$ such that $\fun{hashScript}~s~=~pid$. When a transaction attempts to create or destroy tokens
    that fall under the policy ID $\var{pid}$,
    $s$ verifies that the transaction
    respects the restrictions that are imposed by the monetary policy.
    See sections \ref{sec:transactions} and \ref{sec:utxo} for details.

  \item $\AssetName$ is a type used to distinguish different tokens with the same $\PolicyID$.
    Each $aname$ identifies a unique kind of token in $\var{pid}$.

  \item $\Quantity$ is an integer type that represents an amount of a specific $\AssetName$. We associate
    a term $q\in\Quantity$ with a specific token to track how much of that token is contained in a given asset value.

  \item $\Value$ is the multi-asset type that is used to represent
    a collection of tokens, including Ada. If $(\var{pid}, \var{aname})$ is an $\AssetID$ and $v \in \Value$,
    the quantity in $v$ belonging to that $\AssetID$ is $v~\var{pid}~\var{aname}$.
    Tokens are fungible with each other if and only if they belong to the same $\AssetID$,
    i.e. they have the same $\PolicyID$ and $\AssetName$. Terms of type $\Value$ are sometimes also referred to as
    \emph{token bundles}.

  \item $\mathsf{adaPolicy}$ and $\mathsf{adaName}$ are the $\PolicyID$ and $\AssetName$ of Ada respectively.
    It is not possible to mint any token with the $\PolicyID$ $\mathsf{adaPolicy}$, which means that every
    token in the UTxO belonging to $\mathsf{adaPolicy}$ will have $\AssetName$ $\mathsf{adaName}$.

  \item $\mathsf{size}$ returns the size (in units of memory, eg. bytes or words) of a $\Value$.
  We give this function, alongside implementation-specific constants we have used in it in Section \ref{sec:value-size}.

  \item $\fun{inject}$ and $\fun{coin}$ convert between the two types,
  by building a $\Value$ that only contains Ada given by the input, and extracting
  the amount of Ada as (a $\Coin$) from a $\Value$ respectively.
  Note that composed as

  \[\fun{coin} \circ \fun{inject} = \fun{id}_{\Coin}\]

  these functions give the identity on $\Coin$, but composed in the opposite order as

  \[\fun{inject} \circ \fun{coin}\]

  they return a $\Value$ containing only the Ada tokens contained in the original $\Value$.

  \item $\fun{adaOnly}$ returns $\True$ if a given $\Value$ contains only Ada.
\end{itemize}

\subsection*{Value Operations and Partial Order}
We require some operations on $\Value$, including equality, addition and $\leq$ comparison.

Addition and binary relations are extended pointwise from $\Coin$ to $\Value$, so if $R$ is a binary relation defined on $\Coin$, like $=$ or $\leq$, and $v, w$ are values, we define

\[ v~R~w :\Leftrightarrow \forall~\var{pid}~\var{aname}, (v~\var{pid}~\var{aname})~R~(w~\var{pid}~\var{aname}) \]
\[ (v + w)~\var{pid}~\var{aname} := (v~\var{pid}~\var{aname}) + (w~\var{pid}~\var{aname}). \]
