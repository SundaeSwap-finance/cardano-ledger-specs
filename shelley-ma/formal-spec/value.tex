\section{Coin and Multi-Asset Tokens}
\label{sec:coin-ma}

In this chapter we introduce an algebraic structure, $\ValMonoid$,
which we define to be a monoid with several additional functions.
The monoidal structure and additional functions represent the
features required in order to treat terms as \emph{assets},
which includes the ability to do certain accounting operations on them (addition, etc.),
as well as some other operations (see below).
These operations are used to describe the ShelleyMA transaction processing rules
without indicating what concrete type the $\ValMonoid$ monoid must be.

In order to give a concrete ledger specification, a concrete type
endowed with $\ValMonoid$ structure must be used in its place.
Depending on the concrete type selected for this purpose,
we obtain distinct ledgers. In particular, we get

\begin{itemize}
  \item the Allegra ledger rules with $\Coin$, and
  \item the Mary ledger rules with $\Value$ (a type that represents a heterogeneous collection of assets in a
  single term)
\end{itemize}

Below we give the definitions of all the functions that must be defined on
$\Coin$ and $\Value$ in order for them to have the structure of $\ValMonoid$.
In Section \ref{sec:other-valmonoids} we give several other types which we can meaningfully
support the definition of the required functions (addition, size, etc.), including
an optimized representation that more accurately represents the ledger implementation
of the multi-asset type.
These types are convertible to and from the $\Value$ type, and appear in other
parts of the system as a multi-asset representation which is more suitable in particular
usecases.

\subsection{$\ValMonoid$}

Figure \ref{fig:ValMonoid} gives names and types of functions which
make up the $\ValMonoid$ structure.

%%
%% Figure ValMonoid and its Functions
%%
\begin{figure}[htb]
  \begin{align*}
      & \mathsf{ValType} ~\in~ \mathsf{Type}  \\
      & \text{A type}
      \nextdef
      %
      & \fun{zero} ~\in~ \mathsf{ValType} \\
      & \text{Additive identity of $\mathsf{ValType}$}
      \nextdef
      %
      & (+) ~\in~ \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Addition on $\mathsf{ValType}$}
      \nextdef
      %
      & (*) ~\in~ \mathsf{Integer} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & \text{Scale $\mathsf{ValType}$ value by integral constant}
      \nextdef
      %
      & (-) ~\in~ \mathsf{ValType} \to \mathsf{ValType} \to \mathsf{ValType}\\
      & v_1~-~v_2 ~=~ v_1~+~((-1)~*~v_2)\\
      & \text{Subtraction on $\mathsf{ValType}$}
      \nextdef
      %
      & \fun{isZero} ~\in~ \mathsf{ValType} \to \Bool\\
      & \fun{isZero}~v~=~(v~==~\fun{zero}) \\
      & \text{Is a given $\mathsf{ValType}$ term the additive identity?}
      \nextdef
      %
      & \fun{coin} ~\in~ \mathsf{ValType} \to \Coin\\
      & \text{Return the Ada contained in a $\mathsf{ValType}$ term}
      \nextdef
      %
      & \fun{inject} ~\in~ \Coin \to \mathsf{ValType}\\
      & \text{Create a $\mathsf{ValType}$ term containing only this amount of Ada}
      \nextdef
      %
      & \fun{adaOnly} ~\in~ \mathsf{ValType} \to \Bool \\
      & \fun{adaOnly} =
        \begin{cases}
          \True & \fun{inject} \circ \fun{coin}~ = ~\fun{id}_{\mathsf{ValType}} \\
          \False & \text{otherwise}
        \end{cases} \\
      & \text{Check if a given $\mathsf{ValType}$ term contains only Ada}
      \nextdef
      %
      & \fun{modifyCoin} ~\in~ (\Coin \to \Coin) \to (\mathsf{ValType} \to \mathsf{ValType})\\
      & \text{Modify the Ada part of $\mathsf{ValType}$}
      \nextdef
      %
      & \fun{size} ~\in~ \mathsf{ValType} \to \MemoryEstimate\\
      & \text{Return the size in words of a $\mathsf{ValType}$ term}
      \nextdef
      %
      & \fun{pointwise} ~\in~ (\Integer \to \Integer \to \Bool) \to (\mathsf{ValType} \to \mathsf{ValType} \to \Bool)\\
      & \text{Pointwise comparison of two $\mathsf{ValType}$ terms}
  \end{align*}
  \caption{The $\ValMonoid$ Structure}
  \label{fig:ValMonoid}
\end{figure}

Note that any $\ValMonoid$ must also have the following function, which gives
the size of the serialized representation of a term of the underlying type.
This function is used in the UTXO rule.
We do not include it in the monoid definition because it cannot be defined
explicity separately from concrete implementation.

\[ \fun{serSize} ~\in~ \mathsf{ValType} \to \MemoryEstimate \]

\subsection{$\Coin$ in the Allegra era}

For the Allegra era, we require the $\ValMonoid$ asset representation to support
only a single asset, Ada, whose type we call $\Coin$. This section defines the
$\ValMonoid$ functions for the $\Coin$ type, see Figure
\ref{fig:coin}. Addition and multiplication are defined in the usual way
(as on $\Integer$).

When multi-asset support on the ledger is introduced, Ada ($\Coin$) is still expected to be
the most common type of token on the ledger.
It is the only
type of token that can be used for all non-UTxO ledger accounting, including deposits,
fees, rewards, treasury, and the proof of stake protocol. For this reason, not
all occurrences of $\Coin$ inside a transaction or in the ledger state can or
should be replaced with the abstract $\ValMonoid$.

%%
%% Figure Coin Functions
%%
\begin{figure}[htb]
  \begin{align*}
      & \fun{zero} ~=~ 0
      \nextdef
      %
      & \fun{coin} ~=~ \fun{id}_{\Coin}
      \nextdef
      %
      & \fun{inject} ~=~ \fun{id}_{\Coin}
      \nextdef
      %
      & \fun{modifyCoin} ~=~ \fun{id}_{(\Coin \to \Coin)}
      \nextdef
      %
      & \fun{size}~\wcard ~=~ 0
      \nextdef
      %
      & \fun{pointwise} ~=~ \fun{id}_{(\Integer \to \Integer \to \Bool)}
  \end{align*}
  \caption{$\ValMonoid$ structure with $\Coin$}
  \label{fig:coin}
\end{figure}



\noindent \textbf{Relation between $\fun{inject}$ and $\fun{coin}$.}
When composed as

\[\fun{coin} \circ \fun{inject} = \fun{id}_{\Coin}\]

these functions give the identity on $\Coin$, but composed in the opposite order as

\[\fun{inject} \circ \fun{coin}\]

they return a $\ValMonoid$ containing only the Ada tokens contained in the original $\ValMonoid$.

\textbf{Fungible and non-fungible tokens.}
Recall that a token is said to be fungible at a specific time (slot $s$, for example) if
there are two or more tokens in existence on the ledger that are indistinguishable from
each other, ie. they have the exact same identifier. Tokens with the same
identifier are fungible with each other, but not with tokens with a different identifier.

If there exists only a single
token with a given identifier, it is said to be unique (or non-fungible).
The usual meaning of \emph{non-fungible token} implies, additionally to the
requirement that a token is unique on the ledger at a given time, that
it is programmatically guaranteed to remain unique indefinitely. This
type of guarantee can be encoded in a minting policy.


\subsection{Multi-assets and $\Value$ in the Mary Era}

Terms of the $\Value$ type represent heterogeneous collections of assets,
both user-defined, and Ada. In place of the abstract $\ValMonoid$ structure,
this type is used in the concrete Mary era ledger.
This section describes the type $\Value$, the operations required on
it, its relation to $\Coin$. It also as gives the definitions of the
$\ValMonoid$ functions on $\Value$.

Figure \ref{fig:defs:value} introduces the basic types that make up the $\Value$ type,
as well as defining the functions required to for $\Value$ to be a $\ValMonoid$.

\begin{figure*}[t!]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{aname} & ~\AssetName & \mathsf{ByteString} \\
      \var{pid} & \PolicyID & \ScriptHash \\
      \var{adaID} & ~\AdaIDType & \{~\mathsf{AdaID}~\} \\
      \var{aid} & \AssetID & \AdaID \uniondistinct (\PolicyID \times \AssetName) \\
      \var{quan} & \Quantity & \Z \\
      %\text{quantity of a token}\\
      \var{v}, \var{w} & \Value & \AssetID \mapsto_0 \Quantity
%      & \text{a collection of tokens}
    \end{array}
  \end{equation*}
  %
  \emph{$\ValMonoid$ and auxiliary functions for $\Value$}
  %
  \begin{align*}
    & \fun{policies} ~\in~ \Value \to \powerset{\PolicyID} \\
    & \fun{policies}~v ~=~ \{~\var{pid}~\vert~(\var{pid,~\wcard})~\in~\supp{~v}~\}
    \nextdef
    %
    & \fun{anames} ~\in~ \Value \to \powerset{\AssetName} \\
    & \fun{anames}~v ~=~ \{~\var{aname}~\vert~(\var{\wcard,~aname})~\in~\supp{~v}~\}
    \nextdef
    %
    & \fun{zero} ~=~ \Nothing
    \nextdef
    %
    & \fun{coin}~\var{v} ~=~ \var{v}~\mathsf{AdaID}
    \nextdef
    %
    & \fun{inject}~c  ~=~ \mathsf{AdaID}~\mapsto_0~\var{c}
    \nextdef
    %
    & \fun{modifyCoin}~\var{f}~\var{v}  ~=~ \{~\var{aid}~\mapsto_0~\var{q}~\in~\var{v}~\vert~\var{aid}~\neq~\mathsf{AdaID}~\}~
    \cup~\{~\mathsf{AdaID}~\mapsto_0~\var{f}~(c)~\}
    \nextdef
    %
    & \fun{size} ~~~ \text{see Section \ref{sec:value-size}}
  \end{align*}
  \caption{$\ValMonoid$ Function Definitions and Auxiliary Functions for Value}
  \label{fig:defs:value}
\end{figure*}

\begin{itemize}
  \item $\PolicyID$ identifies monetary policies. A policy ID $\var{pid}$ is associated with a script
    $s$ such that $\fun{hashScript}~s~=~pid$. When a transaction attempts to create or destroy tokens
    that fall under the policy ID $\var{pid}$,
    $s$ verifies that the transaction
    respects the restrictions that are imposed by the monetary policy.
    See sections \ref{sec:transactions} and \ref{sec:utxo} for details.

  \item $\AssetName$ is a byte string used to distinguish different tokens with the same $\PolicyID$.
    Each $aname$ identifies a unique kind of token out of all the tokens under the
    $\var{pid}$ policy (but not necessarily among tokens under other policies).
    The maximum length of this
    byte string is 32 bytes (this is not explicitly enforced in this spec).

  \item $\AssetID$ is either $\mathsf{AdaID}$ or a pair of a policy ID and an asset name.
  It is a unique and permanent
  identifier of an asset. That is, there are is no mechanism to change it or
  any part of it for any token.

  Mary MA tokens are fungible with each other if and only if they have to the same $\AssetID$.
  The reason the unique identifier is a pair of two terms (except for the non-mintable Ada case) is to allow
  minting arbitrary collections of fungible and unique tokens under a single policy.

  \item $\mathsf{AdaID}$ is a special asset ID for Ada, different than all other asset IDs.
  It does not include a policy, and so does not allow Ada to ever be minted or burned.

  \item $\Quantity$ is an integer type that represents an amount of a specific $\AssetName$. We associate
    a term $q\in\Quantity$ with a specific token to track how much of that token is contained in a given asset value.

  \item $\Value$ is the multi-asset type that is used to represent
    a collection of tokens, including Ada. This type is a finitely supported map.

    If $\var{aid}$ is an $\AssetID$ and $v \in \Value$,
    the quantity of tokens with that assed ID contained in $v$ is $v~\var{aid}$.
    Terms of type $\Value$ are sometimes also referred to as
    \emph{token bundles}.

  \item $\fun{inject}$ takes a $\Coin$ amount and returns a $\Value$ containing
  that amount of Ada, ie. tokens associated with the $\mathsf{AdaID}$ asset ID.

  \item $\fun{coin}$ returns the amount of Ada contained in a $\Value$ term (ie.
  the amount of tokens associated with the $\mathsf{AdaID}$ asset ID).
\end{itemize}

\noindent \textbf{Special Ada representation.}
Although all tokens are native on the Cardano ledger (ie. the accounting and
transfer logic for them is done directly by the ledger), Ada is still treated in a
special way by the ledger rules, and is the most common type of asset on the ledger.
It can
be used for special purposes (such as fees) for which other assets cannot be used.
The underlying consensus algorithm relies on Ada in a way that
cannot be extended to user-defined tokens.
Ada can also neither be minted nor burned.

Note that in the $\Value$ definition above, we pick a special asset ID for Ada, that
is not part of the type which represents the asset IDs for all other tokens.
Combining the asset name and policy for Ada gives a type-level guarantee that there is exactly
one kind of token that is associated with it in any way, rather than
deriving this guarantee as an emergent property of minting rules.

Additionally, not giving Ada an actual policy ID
(that could have a hash-associated policy) eliminates the possibility
certain cryptographic attacks.
We sometimes refer to Ada as the primary or principal currency. Ada does not,
for the purposes of the Mary ledger spec, have a $\PolicyID$ or an $\AssetName$.

\subsection{Pointwise Value Operations and Partial Order}
We have a number of operations on $\Value$ left to define for it to have
$\ValMonoid$ structure. These are binary relations, addition, and
scalar multiplication. These are all done
pointwise in accordance with the usual definitions of these operations on
finitely supported maps, see Figure \ref{fig:pointwise}.

\begin{figure*}[t!]
  \begin{align*}
    & v~+~w =& \{~ aid~\mapsto_0 ~((v~\var{aid})~*~(w~\var{aid})) ~\vert~ \var{aid} \in (\fun{dom}~v)\cup(\fun{dom}~w) ~\}
    \nextdef
    %
    & q~*~v =& \{~ aid~\mapsto_0 ~(q~*~(v~\var{aid})) ~\vert~ \var{aid} \in \fun{dom}~v~\}
    \nextdef
    %
    & \fun{pointwise}~R~v~w =& \forall~\var{aid} ~\in ~(\fun{dom}~v~\cup~\fun{dom}~w),~R~(v~\var{aid})~(w~\var{aid})
  \end{align*}
  \caption{Pointwise operations on Value}
  \label{fig:pointwise}
\end{figure*}
