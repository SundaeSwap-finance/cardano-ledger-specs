\section{Other $\ValMonoid$ Examples}
\label{sec:other-valmonoids}

We give examples here of $\ValMonoid$-structured types
that are types similar to $\Value$ token bundles in spirit, and are used elsewhere
in the system (eg. the wallet).

\subsection{No Special Case for Ada}

In an original paper about native multi-asset representation in a UTxO ledger
(see \cite{utxo_ma}), the token bundle definition avoids all special cases, treating
all tokens in a uniform way.
While it does not define any special cases of its multi-asset tokens at the type-level,
it does not prohibit the possibility of customizing the ledger rules to introduce
some special treatment of any specific tokens if needed.

In Figure \ref{fig:no-special-ada}, we give the $\ValMonoid$ functions for
the $\Value'$ type, which has no special case for Ada. That is, the policy and
asset name for it are chosen as a term of the corresponding type. This means
that Ada indeed has a minting policy, $\mathsf{AdaPolicyID}$. It must be specified in
order to implementat of this version of token bundles, but we leave abstract here.
Ada could potentially have several asset names scoped under this policy, although
practically this would not line up with the current ledger conception of Ada.
We call Ada's asset name $\mathsf{AdaName}$, and leave it unspecified here. \\~\\

\begin{figure*}[t!]
  \emph{Constants}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{~}lr}
      \mathsf{AdaPolicyID} & \PolicyID & \text{Policy ID of Ada} \\
      \mathsf{AdaName} & \AssetName & \text{Asset name of Ada}
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{v}, \var{w} & \Value'
      & \PolicyID \mapsto_0 ( \AssetName \mapsto_0 \Quantity )
%      & \text{a collection of tokens}
    \end{array}
  \end{equation*}
  %
  \emph{$\ValMonoid$ and auxiliary functions for $\Value'$}
  %
  \begin{align*}
    & \fun{policies}~v ~=~ \supp{~v}
    \nextdef
    %
    & \fun{anames}~v ~=~ \bigcup_{pid \in\fun{policies}{~v}} \supp{(v~pid)}
    \nextdef
    %
    & \fun{zero} ~=~ \Nothing
    \nextdef
    %
    & \fun{coin}~v ~=~ v~\mathsf{AdaPolicyID}~\mathsf{AdaName}
    \nextdef
    %
    & \fun{inject}~c  ~=~ \mathsf{AdaPolicyID}~\mapsto_0~(\mathsf{AdaName}~\mapsto_0~c)
  \end{align*}
  \caption{$\ValMonoid$ Function Definitions and Auxiliary Functions for $\Value'$}
  \label{fig:no-special-ada}
\end{figure*}


\subsection{Special Case Ada Representation}
\label{sec:coin-value}

The $\Value_C$ type and the associated functions, shown in Figure \ref{fig:special-ada},
give a $\ValMonoid$ which is isomorphic to the $\Value$ we defined in
Section \ref{sec:coin-ma}. Both constructs
specify all non-Ada tokens via the unique identifier $(\PolicyID \times \AssetName)$, and
have a special case for Ada. Neither token bundle definition
admits a minting policy or an asset name for Ada.

The isomorphism between the two types is defined in Figure \ref{fig:iso-v}.
All $\ValMonoid$ operations on the $\Value$ and $\Value_C$ types commute with this
isomorphism. $\Value$ is a user-facing representation, whereas $\Value_C$
is an optimized internal representation.

\begin{figure*}[t!]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{v}, \var{w} & \Value_C
      & \Coin \times \PolicyID \mapsto_0 ( \AssetName \mapsto_0 \Quantity )
%      & \text{a collection of tokens}
    \end{array}
  \end{equation*}
  %
  \emph{$\ValMonoid$ and auxiliary functions for $\Value_C$}
  %
  \begin{align*}
    & \fun{policies}~(c,~v) ~=~ \supp{~v}
    \nextdef
    %
    & \fun{anames}~(c, ~v) ~=~ \bigcup_{pid \in\fun{policies}{~v}} \supp{(v~pid)}
    \nextdef
    %
    & \fun{zero} ~=~ (0, \Nothing)
    \nextdef
    %
    & \fun{coin}~(\var{c}, \wcard) ~=~ \var{c}
    \nextdef
    %
    & \fun{inject}~c  ~=~ (c, \Nothing)
    \nextdef
    %
    & \fun{size} ~~~ \text{see Section \ref{sec:value-size}}
  \end{align*}
  \caption{$\ValMonoid$ Function Definitions and Auxiliary Functions for $\Value_C$}
  \label{fig:special-ada}
\end{figure*}

\begin{figure*}[t!]
  \begin{align*}
    & \fun{iso_v} ~\in~ \Value \to \Value_C \\
    & \fun{iso_v}~v ~=~(\var{v}~\mathsf{AdaID},~\{~\var{pid}~\mapsto_0~(\var{aname}~\mapsto_0~\var{q})~
    \vert~(\var{pid},~\var{aname})~\in~\fun{dom}~{v}~\})
    \nextdef
    %
    & \fun{iso}_{vc} ~\in~ \Value_C \to \Value \\
    & \fun{iso}_{vc}~(c, ~v) ~=~ \{~\mathsf{AdaID}~\mapsto_0~c~\}~\cup~
     \{~(\var{pid},~\var{aname})~\mapsto_0~q~\vert~\var{pid}~\mapsto_0~(\var{aname}~\mapsto_0~q)~ \in~\var{v}~\}
  \end{align*}
  \caption{Isomorphism maps between the $\Value$ and $\Value_C$ types}
  \label{fig:iso-v}
\end{figure*}

\noindent \textbf{$\mathsf{CompactValue}$ Representation.}
The type $\mathsf{CompactValue}$ is a compressed representation of $\Value_C$.
We do not give the implementation details of this compression here.
This representation of multi-assets is isomorphic to $\Value$ and $\Value_C$.
It is used in the implementation to save memory, but the all operations on
this $\ValMonoid$ type are are defined directly in terms of $\Value_C$ operations,
so that they first require de-compression to be performed, as well as compression
as the final step in the cases the output type contains $\Value_C$.
